<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>World Manipulation - Controller Support</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.0/dist/aframe-extras.min.js"></script>
 
    <script>
      /* 世界を操作するコンポーネント */
      AFRAME.registerComponent('world-mover', {
        init: function () {
          this.leftStick = { x: 0, y: 0 };
          this.rightStick = { x: 0, y: 0 };
          
          // コントローラーのスティック入力を監視
          this.el.sceneEl.addEventListener('axismove', (evt) => {
            // 左手スティック: 移動 (x, z)
            if (evt.detail.axis.length <= 2) { // 簡易判定
               this.leftStick.x = evt.detail.axis[2] || 0;
               this.leftStick.y = evt.detail.axis[3] || 0;
            } else {
               // 右手スティック: 回転
               this.rightStick.x = evt.detail.axis[2];
            }
          });
        },
        tick: function (time, delta) {
          const dt = delta / 1000;
          const moveSpeed = 10 * dt;
          const rotSpeed = 45 * dt;

          // 世界の位置を動かす (左スティック)
          let pos = this.el.getAttribute('position');
          pos.x -= this.leftStick.x * moveSpeed;
          pos.z -= this.leftStick.y * moveSpeed;
          this.el.setAttribute('position', pos);

          // 世界を回転させる (右スティック)
          let rot = this.el.getAttribute('rotation');
          rot.y += this.rightStick.x * rotSpeed;
          this.el.setAttribute('rotation', rot);
        }
      });

      /* 落下コンポーネント (変更なし) */
      AFRAME.registerComponent('petal-fall', {
        schema: { floorY: { type: 'number', default: -10 }, topY: { type: 'number', default: 50 } },
        init: function () {
          this.reset();
          this.speed = 0.8 + Math.random() * 1.2;
          this.yokoA = 0.01 + Math.random() * 0.25;
          this.yokoF = 400 + Math.random() * 200;
          this.kaitens = Math.random() * 1.0;
          this.rotAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
        },
        reset: function () {
          const angle = Math.random() * Math.PI * 2;
          const minR = 0, maxR = 100; // 世界が動くので範囲を少し狭める
          const t = Math.random();
          const radius = Math.sqrt(minR*minR + t * (maxR*maxR - minR*minR));
          const x = radius * Math.cos(angle);
          const z = radius * Math.sin(angle);
          this.el.setAttribute('position', `${x} ${this.data.topY} ${z}`);
        },
        tick: function (time, delta) {
          const dt = delta / 1000;
          const obj = this.el.object3D;
          obj.position.y -= this.speed * dt;
          obj.position.x += Math.sin(time / this.yokoF) * this.yokoA;
          obj.rotateOnAxis(this.rotAxis, this.kaitens * dt);
          if (obj.position.y < this.data.floorY) this.reset();
        }
      });

      /* 桜リング配置 (変更なし) */
      AFRAME.registerComponent('skr', {
        schema: {
          radii: { type: 'string', default: '50, 200' },
          counts: { type: 'string', default: '8, 60' },
          model: { type: 'string', default: '#test1' },
          yOffset: { type: 'number', default: -10 },
          scales: { type: 'string', default: '20 20 20 | 20 20 20' }
        },
        init: function () {
          const data = this.data;
          const radiiArray = data.radii.split(',').map(r => parseFloat(r.trim()));
          const countsArray = data.counts.split(',').map(c => parseInt(c.trim()));
          const scalesArray = data.scales.split('|').map(s => s.trim());
          radiiArray.forEach((radius, layerIndex) => {
            const count = countsArray[layerIndex] || countsArray[0];
            const scale = scalesArray[layerIndex] || scalesArray[0];
            const angleStep = 360 / count;
            for (let i = 0; i < count; i++) {
              const angle = i * angleStep;
              const rad = THREE.MathUtils.degToRad(angle);
              const x = radius * Math.sin(rad);
              const z = -radius * Math.cos(rad);
              const modelEl = document.createElement('a-entity');
              modelEl.setAttribute('gltf-model', data.model);
              modelEl.setAttribute('scale', scale);
              modelEl.setAttribute('position', `${x} ${data.yOffset} ${z}`);
              modelEl.setAttribute('rotation', `0 ${Math.random() * 360} 0`);
              this.el.appendChild(modelEl);
            }
          });
        }
      });

      document.addEventListener('DOMContentLoaded', () => {
        const world = document.querySelector('#world-content');
        const COUNT = 300;
        for (let i = 0; i < COUNT; i++) {
          const ent = document.createElement('a-entity');
          ent.setAttribute('petal-fall', { floorY: -10, topY: 50 });
          ent.setAttribute('scale', '0.5 0.5 0.5');
          ent.setAttribute('gltf-model', '#test2');
          world.appendChild(ent);
        }
      });
    </script>
  </head>
 
  <body>
    <a-scene>
      <a-assets>
        <a-asset-item id="test1" src="sakuranoki_1ver2.glb"></a-asset-item>
        <a-asset-item id="test2" src="hanabira.glb"></a-asset-item>
        <a-asset-item id="kusa" src="kusa8.glb"></a-asset-item>
        <a-asset-item id="sky" src="sky2.glb"></a-asset-item>
      </a-assets>

      <a-entity id="rig">
        <a-entity camera position="0 1.6 0" look-controls></a-entity>
        <a-entity oculus-touch-controls="hand: left"></a-entity>
        <a-entity oculus-touch-controls="hand: right"></a-entity>
      </a-entity>
 
      <a-entity id="world" world-mover>
        <a-entity id="world-content">
          <a-entity gltf-model="#kusa" position="0 -10 0" scale="100 100 100"></a-entity>
          <a-entity skr="radii: 50, 200; counts: 8, 60; scales: 80 80 80 | 80 80 80; model: #test1; yOffset: -10;"></a-entity>
        </a-entity>
      </a-entity>

      <a-entity gltf-model="#sky" position="0 0 0" rotation="0 90 0" scale="10 10 10"></a-entity>
 
    </a-scene>
  </body>
</html>